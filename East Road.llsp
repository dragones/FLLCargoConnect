# imports -------------------------------------------------------------------------

from spike import PrimeHub, LightMatrix, Button, StatusLight, ForceSensor, MotionSensor, Speaker, ColorSensor, App, DistanceSensor, Motor, MotorPair
from spike.control import wait_for_seconds, wait_until, Timer
from spike.operator import less_than
from spike.operator import greater_than

# variables -----------------------------------------------------------------------

hub = PrimeHub()
motor_l_r = MotorPair('C','D')
motor_r = Motor('D')
motor_l = Motor('C')
motor_front = Motor('E')
color_r = ColorSensor('B')
color_l = ColorSensor('A')
motor_rear = Motor('F')
timer = Timer()

# functions -----------------------------------------------------------------------

def gyro_follower(target, k, power):
    # gets the current yaw angle
    degrees = hub.motion_sensor.get_yaw_angle()
    # makes the error variable
    error = target - degrees
    # making the steering correction
    steering = int(error*k)
    # makes sure the robot stays on the threshold
    motor_l_r.start_at_power(power,steering)

def gyro_follower_loop(target, k, power, distance):
    while get_motor_r()<distance:
        gyro_follower(target,k,power)
    motor_l_r.stop()

def gyro_follower_loop_reset(target, k, power, distance, reset):
    if reset:
        gyro_reset()
        motor_r_reset()
    gyro_follower_loop(target, k, power, distance)

def rev_gyro_follower(target, k, power):
    # gets the current yaw angle
    degrees =hub.motion_sensor.get_yaw_angle()
    # makes the error variable
    error =degrees-target
    # making the steering correction
    steering = int(error*k)
    # makes sure the robot stays on the threshold
    motor_l_r.start_at_power(power,steering)

def rev_gyro_follower_loop(target, k, power, distance):
    while get_motor_r()>distance:
        rev_gyro_follower(target,k,power)
    motor_l_r.stop()

def rev_gyro_follower_loop_reset(target, k, power, distance, reset):
    if reset:
        gyro_reset()
        motor_r_reset()
    rev_gyro_follower_loop(target, k, power, distance)

def line_follower(target, k, power, sensor, side):
    # gets the current reflected light
    if sensor == 'right': #chooses right color sensor
        light =color_r.get_reflected_light()
    elif sensor == 'left': #chooses left color sensor
        light =color_l.get_reflected_light()
    # makes the error variable
    if side == 'left': # chooses left side of black line
        error =target-light
    elif side == 'right': #chooses right side of black line
        error = light-target
    # makes the steering correction
    correction = int(error*k)
    # steers the robot toward the target
    right_power=power+correction
    left_power=power-correction
    motor_l_r.start_tank_at_power(left_power,right_power)

def line_follower_loop(target, k, power, sensor, side, distance):
    while get_motor_r()<distance:
        line_follower(target, k, power, sensor, side)
    motor_l_r.stop()

def turn_right(target_angle, power, turn_type):
    if target_angle < 0:
        print('target_angle is negative')
        return
    # make the gyro angle variables that checks the gyro angle
    gyro_angle1= hub.motion_sensor.get_yaw_angle()
    gyro_angle2= hub.motion_sensor.get_yaw_angle()
    # start turn loop
    while gyro_angle2 < gyro_angle1+target_angle:
        if turn_type == 'pivot': #chooses pivot turn
            motor_l_r.start_tank_at_power(power,0)
        elif turn_type == 'zero': #chooses zero point turn
            motor_l_r.start_tank_at_power(power,-1*power)
        # checks gyro angle and sets it to the current one
        gyro_angle2 = hub.motion_sensor.get_yaw_angle()
    motor_l_r.stop()

def turn_left(target_angle, power, turn_type):
    if target_angle > 0:
        print('target_angle is positive')
        return
    # make the gyro angle variable that checks the gyro angle
    gyro_angle1= hub.motion_sensor.get_yaw_angle()
    gyro_angle2= hub.motion_sensor.get_yaw_angle()
    # start turn loop
    while gyro_angle2 > gyro_angle1+target_angle:
        if turn_type == 'pivot': #chooses pivot turn
            motor_l_r.start_tank_at_power(0, power)
        elif turn_type == 'zero': #chooses zero point turn
            motor_l_r.start_tank_at_power(-1*power,power)
        # checks gyro angle and sets it to the current one
        gyro_angle2 = hub.motion_sensor.get_yaw_angle()
    motor_l_r.stop()

def motor_r_reset():
    motor_r.set_degrees_counted(0)

def gyro_reset():
    hub.motion_sensor.reset_yaw_angle()

def get_yaw():
    return hub.motion_sensor.get_yaw_angle()

def get_color_l():
    return color_l.get_reflected_light()

def get_color_r():
    return color_r.get_reflected_light()

def get_motor_r():
    return motor_r.get_degrees_counted()

def square_on_line(speed):
    # check if speed negative
    if speed < 0:
        print('speed parameter is negatifve.  speed parameter must be postive')
        hub.status_light.on('red')
        return

    gyro_reset()

    while get_color_l() > 25 and get_color_r() > 25:
        gyro_follower(0,6,speed)
    motor_l_r.stop()

    while get_color_l() > 25 or get_color_r() > 25:
        if(get_color_l() > 25):
            motor_l_r.move_tank(10,'degrees',speed,-speed)
        elif(get_color_r() > 25):
            motor_l_r.move_tank(10,'degrees',-speed,speed)
        motor_l_r.move_tank(10,'degrees',speed,speed)
    motor_l_r.stop()

# start program --------------------------------------------------------------------

# 3,2,1 lego--move out of launch after button press
hub.light_matrix.show_image('HAPPY')
hub.right_button.wait_until_pressed()
hub.light_matrix.off()

motor_r_reset()
gyro_reset()
timer.reset()

# M13: drop off trucks
gyro_follower_loop(0,6,40,600)

line_follower_loop(55, .35, 30, 'right','left', 1300)
line_follower_loop(55, .25, 50, 'right','left', 1850)

# M14: drop down bridges
motor_rear.set_degrees_counted(0)
motor_rear.run_for_degrees(-145, 20)

#line follow passed bridge
gyro_reset()
gyro_follower_loop(0,6,40,2710) 

#drop down right bridge
motor_rear.set_degrees_counted(0)
motor_rear.run_for_degrees(-550, 40) 
motor_rear.run_for_degrees(140, 40) 

# M16: put container in cargo conect circle and other circles
gyro_reset()
turn_right(80, 30,'zero')

rev_gyro_follower_loop_reset(0,6,-30,-50,True)

motor_front.set_degrees_counted(0)
motor_front.run_for_degrees(-200, 30)

# M08: helicopter

#rotate back to line
gyro_follower_loop_reset(0,6,30,50,True)
turn_left(-80, 30,'zero')

rev_gyro_follower_loop_reset(0,6,-30,-200,True) #-250 

# advance to helicopter
while get_motor_r()< -100: #100
    line_follower(55, .35, 15, 'right','left') 
while get_motor_r()< 950: #900
    line_follower(55, .2, 45, 'right','left') #50

#raise SystemExit

motor_r_reset()
current_degrees = hub.motion_sensor.get_yaw_angle()
gyro_follower_loop(current_degrees,6 ,50,270)

# M09: train down track 
rev_gyro_follower_loop_reset(0,6,-30,-170,True)
turn_left(-55, 30, 'pivot')
motor_rear.set_degrees_counted(0)
motor_rear.run_for_degrees(-130,30)

motor_r_reset()
gyro_reset()
while get_motor_r()>-750:
    rev_gyro_follower(0,6,-100)
while get_motor_r()>-920:  
    rev_gyro_follower(0,6,-70)
motor_l_r.stop()

# M07: crane mission
turn_left(-35, 30, 'pivot')

# square off on black lines
square_on_line(40) #30
turn_left(-57,30,'pivot')
gyro_reset()
motor_r_reset()
while get_motor_r()<600:
    gyro_follower(0,6,40)
square_on_line(30)

gyro_reset()
turn_right(90,30,'zero') 
square_on_line(30)

gyro_reset()
turn_left(-85,30,'zero')
motor_rear.run_for_degrees(-180,50)
rev_gyro_follower_loop_reset(0, 6, -40, -400, True)

# MO6: accident avoidence
motor_r_reset()
while get_motor_r()<69:
    gyro_follower(0,6,30)

motor_r_reset()
line_follower_loop(55, .30, 30, 'right','left',575)

turn_right(90,30,'pivot')
motor_rear.run_for_degrees(-60,50)
gyro_follower_loop_reset(0,6,40,269,True)
turn_left(-90, 30, 'pivot')

rev_gyro_follower_loop_reset(0, 6, -30, -40, True)

# drop panel
motor_front.run_for_degrees(140,20)
motor_front.run_for_degrees(-140,20)

# park on blue line
gyro_follower_loop_reset(0, 6, 30, 200, True)

#raise SystemExit
